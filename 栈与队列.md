## 栈与队列
### 栈
```text
栈是限定仅在表尾进⾏插⼊和州除操作的线性表。
```
### ADT
```text
ADT 栈（stack）

    Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
    
    Operation
    
        Initstack（*s)：初始化操作，建⽴⼀个空栈S。 
        Destroystack（*s)：若栈存在，则销毁它。 
        Clearstack（*s）：将栈清空。 
        StackEmpty(S)：若栈为空，返回 true，否则返回 false。 
        CetTop(S,*e）：若栈存在且⾮空，⽤：返回S的栈顶元素。 
        Push (*S,e）：若栈§ 存在，插⼊新元素e到栈S中并成为栈顶元素。 
        Pop（*S,*e）：删除栈S中栈顶元素，并⽤e返回其值。 
        StackLength(s)：返回栈S的元素个数。 
endADT
```
### 顺序栈（顺序存储结构）
#### 优势
- 只准栈顶进出元素，不存在线性表插入和删除时需要移动元素的问题
#### 劣势
- 必须事先确定数组存储空间大小，万一不够用了，需要用编程的手段来扩展数组的容量
#### 两栈共享内存
```text
使用场景：
1. 两个栈具备相关的数据类型
2. 当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短
```
### 链栈（链表存储结构）
### 中缀表达式转后缀表达式
```text
中缀表达式a + b*c + (d * e + f) * g，其转换成后缀表达式则为a b c * + d e * f  + g * +。

转换过程需要用到栈，具体过程如下：

    1.从左到右进行遍历
    2.运算数,直接输出.
    3.左括号,直接压入堆栈,(括号是最高优先级,无需比较)(入栈后优先级降到最低,确保其他符号正常入栈)
    4.右括号,(意味着括号已结束)不断弹出栈顶运算符并输出直到遇到左括号(弹出但不输出)
    5.运算符,将该运算符与栈顶运算符进行比较, 
        如果优先级高于栈顶运算符则压入堆栈(该部分运算还不能进行),
        如果优先级低于等于栈顶运算符则将栈顶运算符弹出并输出,然后比较新的栈顶运算符.
        (低于弹出意味着前面部分可以运算,先输出的一定是高优先级运算符,等于弹出是因为同等优先级,从左到右运算)
        直到优先级大于栈顶运算符或者栈空,再将该运算符入栈.
    6.如果对象处理完毕,则按顺序弹出并输出栈中所有运算符.
```
### 后缀表达式计算结果
```text
从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进⾏运算，运算结果进栈，⼀直到最终获得结果。
```

### 队列
```text
队列是只允许在⼀端进⾏插⼊操作、⽽在另⼀端进⾏删除操作的线性表。
```
```text
ADT 队列（ Queue）

    Data
    
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
    
    Operation
    
        InitQueue（*Q）：初始化操作，建⽴⼀个空队列 Q。 
        DestroyQueue（*Q）：若队列存在，则销毁它。
        ClearQueue(*Q）：将队列Q清空。 
        QueueEmpty(Q)：若队列Q为空，返回true，否则返回 false。 
        GetHead(Q,*e）：若队列Q 存在且⾮空，⽤e返回队列Q的队头元素。 
        EnQueue(*Q,e）：若队列Q 存在，插⼊新元素e到队列Q中并成为队尾元素。 
        DeQueue(*Q,*e）：删除队列Q中队头元素，并⽤e返回其值。 
        QueueLength(Q)：返回队列Q的元素个数

endADT
```

### 循环队列
```text
头尾相接的顺序存储结构
```